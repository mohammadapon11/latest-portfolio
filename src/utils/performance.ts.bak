// Performance utilities for optimization

// Cache management
class PerformanceCache {
  private cache = new Map<string, any>();
  private maxSize = 100;
  private ttl = new Map<string, number>();

  set(key: string, value: any, ttlMs: number = 300000) { // 5 minutes default
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
      this.ttl.delete(firstKey);
    }

    this.cache.set(key, value);
    this.ttl.set(key, Date.now() + ttlMs);
  }

  get(key: string): any | null {
    const expiry = this.ttl.get(key);
    if (expiry && Date.now() > expiry) {
      this.cache.delete(key);
      this.ttl.delete(key);
      return null;
    }
    return this.cache.get(key) || null;
  }

  clear() {
    this.cache.clear();
    this.ttl.clear();
  }

  size() {
    return this.cache.size;
  }
}

// Global cache instance
export const performanceCache = new PerformanceCache();

// Device capability detection
export const getDeviceCapabilities = () => {
  if (typeof window === 'undefined') {
    return {
      isMobile: false,
      isLowEnd: false,
      supportsWebGL: false,
      cpuCores: 0,
      memory: 0,
      connection: 'unknown'
    };
  }

  const userAgent = navigator.userAgent.toLowerCase();
  const isMobile = /mobile|android|iphone|ipad|phone/i.test(userAgent);
  const cpuCores = navigator.hardwareConcurrency || 1;
  const memory = (performance as any).memory?.jsHeapSizeLimit || 0;
  
  // Determine if device is low-end
  const isLowEnd = cpuCores <= 2 || memory < 100 * 1024 * 1024; // Less than 100MB
  
  // WebGL support detection
  let supportsWebGL = false;
  try {
    const canvas = document.createElement('canvas');
    supportsWebGL = !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
  } catch (e) {
    supportsWebGL = false;
  }

  // Network connection detection
  let connection = 'unknown';
  if ('connection' in navigator) {
    const conn = (navigator as any).connection;
    if (conn.effectiveType) {
      connection = conn.effectiveType;
    } else if (conn.type) {
      connection = conn.type;
    }
  }

  return {
    isMobile,
    isLowEnd,
    supportsWebGL,
    cpuCores,
    memory: Math.round(memory / 1024 / 1024),
    connection
  };
};

// Performance optimization settings based on device capabilities
export const getOptimizedAnimationSettings = () => {
  const capabilities = getDeviceCapabilities();
  
  return {
    disable3D: capabilities.isLowEnd || !capabilities.supportsWebGL,
    simplifiedEffects: capabilities.isLowEnd || capabilities.isMobile,
    reducedAnimations: capabilities.isLowEnd,
    lowerFrameRate: capabilities.isLowEnd,
    disableShadows: capabilities.isLowEnd,
    simplifiedGeometry: capabilities.isLowEnd
  };
};

// Memory usage monitoring
export const getMemoryUsage = () => {
  if (typeof window === 'undefined' || !('memory' in performance)) {
    return null;
  }

  const memory = (performance as any).memory;
  return {
    usedJSHeapSize: Math.round(memory.usedJSHeapSize / 1024 / 1024),
    totalJSHeapSize: Math.round(memory.totalJSHeapSize / 1024 / 1024),
    jsHeapSizeLimit: Math.round(memory.jsHeapSizeLimit / 1024 / 1024)
  };
};

// Debounce function for performance
export const debounce = <T extends (...args: any[]) => any>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout;
  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
};

// Throttle function for performance
export const throttle = <T extends (...args: any[]) => any>(
  func: T,
  limit: number
): ((...args: Parameters<T>) => void) => {
  let inThrottle: boolean;
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
};

// Intersection Observer with performance optimization
export const createIntersectionObserver = (
  callback: IntersectionObserverCallback,
  options: IntersectionObserverInit = {}
) => {
  if (typeof window === 'undefined') return null;

  const defaultOptions: IntersectionObserverInit = {
    threshold: [0, 0.1, 0.5, 1],
    rootMargin: '0px 0px -100px 0px',
    ...options
  };

  try {
    return new IntersectionObserver(callback, defaultOptions);
  } catch (error) {
    console.warn('IntersectionObserver not supported:', error);
    return null;
  }
};

// Performance measurement utility
export const measurePerformance = <T extends (...args: any[]) => any>(
  name: string,
  fn: T
): ((...args: Parameters<T>) => ReturnType<T>) => {
  return (...args: Parameters<T>): ReturnType<T> => {
    const start = performance.now();
    const result = fn(...args);
    const end = performance.now();
    
    if (process.env.NODE_ENV === 'development') {
      console.log(`Performance [${name}]: ${(end - start).toFixed(2)}ms`);
    }
    
    return result;
  };
};

// Image preloading utility
export const preloadImage = (src: string): Promise<void> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve();
    img.onerror = reject;
    img.src = src;
  });
};

// Batch DOM operations for better performance
export const batchDOMOperations = (operations: (() => void)[]) => {
  if (typeof window === 'undefined') return;

  // Use requestAnimationFrame for smooth batching
  requestAnimationFrame(() => {
    operations.forEach(operation => operation());
  });
};

// Performance budget checking
export const checkPerformanceBudget = (metric: string, value: number, budget: number) => {
  const percentage = (value / budget) * 100;
  
  if (percentage > 100) {
    console.warn(`Performance budget exceeded for ${metric}: ${value}ms (budget: ${budget}ms)`);
    return false;
  }
  
  return true;
};

// Optimize scroll performance
export const optimizeScroll = (element: HTMLElement, callback: (event: Event) => void) => {
  let ticking = false;
  
  const handleScroll = (event: Event) => {
    if (!ticking) {
      requestAnimationFrame(() => {
        callback(event);
        ticking = false;
      });
      ticking = true;
    }
  };
  
  element.addEventListener('scroll', handleScroll, { passive: true });
  
  return () => {
    element.removeEventListener('scroll', handleScroll);
  };
};

// Resource hints for better performance
export const addResourceHints = () => {
  if (typeof document === 'undefined') return;

  const hints = [
    { rel: 'preconnect', href: 'https://fonts.googleapis.com' },
    { rel: 'preconnect', href: 'https://fonts.gstatic.com', crossorigin: '' },
    { rel: 'dns-prefetch', href: 'https://fonts.googleapis.com' }
  ];

  hints.forEach(hint => {
    const link = document.createElement('link');
    Object.entries(hint).forEach(([key, value]) => {
      (link as any)[key] = value;
    });
    document.head.appendChild(link);
  });
};

// Export cache instance
export default performanceCache;
